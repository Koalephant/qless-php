#!/usr/bin/env php
<?php

use Monolog\Formatter\LineFormatter;
use Monolog\Handler\StreamHandler;
use Monolog\Logger;
use Monolog\Processor\PsrLogMessageProcessor;
use Phalcon\Cop\Parser;
use Qless\Client;
use Qless\Jobs\Reservers\OrderedReserver;
use Qless\Queues\Collection;
use Qless\Queues\Queue;
use Qless\Workers\ForkingWorker;
use Composer\Autoload\ClassLoader;

if (version_compare('7.1.0', PHP_VERSION, '>')) {
    fprintf(
        STDERR,
        'This version of Qless PHP is supported on PHP >= 7.1.' . PHP_EOL .
        'You are using PHP %s (%s).' . PHP_EOL,
        PHP_VERSION,
        PHP_BINARY
    );

    exit(1);
}

/**
 * Prints the help message.
 *
 * @return void
 */
function help(): void
{
    $help = <<<HLP
Qless PHP

Usage:
  qlessd [options]
 
Options:

  dsn               The Redis backend. Can have simple "host:port" format or use a DSN-style format [default: 127.0.0.1]
  db                The Redis database index [default: 0]
  queue             The queue to work
  queue-spec        The regular expression to fetch queues to work
  prepend           A PHP file to include before Composer's autoloader
  log-name          The fallback logger name [default: qless]
  help              Show this help message
  debug             Use verbose logging
HLP;

    fprintf(STDOUT, $help);

    exit(0);
}

// Find and initialize Composer
$autoload = [
    __DIR__ . '/vendor/autoload.php',
    __DIR__ . '/../../../vendor/autoload.php'
];

foreach ($autoload as $file) {
    if (class_exists(ClassLoader::class, false) == true) {
        break;
    }

    if (file_exists($file)) {
        require_once $file;
    }
}

if (class_exists(ClassLoader::class, false) == false) {
    fprintf(
        STDERR,
        'You need to set up the project dependencies using the following commands:' . PHP_EOL .
        'curl -s http://getcomposer.org/installer | php' . PHP_EOL .
        'php composer.phar install' . PHP_EOL
    );

    exit(1);
}

// Read the command line arguments
$parser = new Parser();
$params = $parser->parse($argv);

if (isset($params['help'])) {
    help();
}

$prepend = $params['prepend'] ?? (getenv('APP_PREPEND') ?: null);
if (empty($prepend) == false) {
    foreach (explode(',', $prepend) as $file) {
        if (file_exists($file) == false) {
            fprintf(STDERR, 'A prepend file "%s" does not exist.' . PHP_EOL, $file);
            exit(1);
        }

        require_once $file;
    }
}

// See if the APP_PREPEND contains a logger object.
// If none exists, fallback to internal logger.
$logName = $params['log-name'] ?? (getenv('LOG_NAME') ?: 'qless');
if (!isset($logger) || $logger instanceof Logger == false) {
    $logger = new Logger($logName, [], [new PsrLogMessageProcessor()]);
}

$debug = false;
if (isset($params['debug'])) {
    $debug = true;
} else {
    $debug = getenv('DEBUG') || getenv('VERBOSE') || getenv('VVERBOSE') || false;
}

if (count($logger->getHandlers()) == 0) {
    $handler = new StreamHandler(STDOUT, $debug ? Logger::WARNING : Logger::DEBUG);

    $handler->setFormatter(
        new LineFormatter(
            "[%datetime%] %level_name%: %message%\n",
            null,
            false,
            true
        )
    );

    $logger->pushHandler($handler);
}

$logger->info('Start initializing qlessd...');
$database = $params['db'] ?? (getenv('REDIS_BACKEND_DB') ?: null);

// Create a client
$client = new Client(
    $params['dsn'] ?? getenv('REDIS_BACKEND') ?: '127.0.0.1',
    empty($database) ? null : (int)$database
);

$queue = $params['queue'] ?? (getenv('QUEUE') ?: null);
if (empty($queue) == true && empty($params['queue-spec']) == true) {
    fprintf(
        STDERR,
        'Set QUEUE env var containing the queue name to work.' . PHP_EOL .
        'Otherwise you can specify a regular expression to fetch queues using "--queue-spec" option' . PHP_EOL .
        'or use "--queue" to set queue to work.' . PHP_EOL
    );

    exit(1);
}

// Get the queues you use.
if (empty($queue) == false) {
    $queues = array_map(function (string $name) use ($client): Queue {
        return $client->queues[trim($name)];
    }, explode(',', $queue));
} else {
    $collection = new Collection($client);
    $queues = $collection->fromSpec($params['queue-spec']);
}

// Create a job reserver; different reservers use different
// strategies for which order jobs are popped off of queues
$reserver = new OrderedReserver($queues);

$worker = new ForkingWorker($reserver, $client);
$worker->setLogger($logger);

$worker->run();

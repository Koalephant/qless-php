#!/usr/bin/env php
<?php

use Composer\Autoload\ClassLoader;
use Monolog\Formatter\LineFormatter;
use Monolog\Handler\StreamHandler;
use Monolog\Logger;
use Monolog\Processor\PsrLogMessageProcessor;
use Phalcon\Cop\Parser;
use Qless\Client;
use Qless\Jobs\Reservers\OrderedReserver;
use Qless\Queues\Collection;
use Qless\Workers\ForkingWorker;
use Qless\Exceptions\RedisConnectionException;

if (version_compare('7.1.0', PHP_VERSION, '>')) {
    fprintf(
        STDERR,
        'This version of Qless PHP is supported on PHP >= 7.1.' . PHP_EOL .
        'You are using PHP %s (%s).' . PHP_EOL,
        PHP_VERSION,
        PHP_BINARY
    );

    exit(1);
}

/**
 * Prints the help message.
 *
 * @return void
 */
function help(): void
{
    $help = <<<HLP
Qless PHP

Usage:
  qlessd [options]
 
Options:

  dsn               The Redis backend. Can have simple "host:port" format or use a DSN-style format [default: 127.0.0.1]
  db                The Redis database index [default: 0]
  queue             The queue to work
  queue-spec        The regular expression to fetch queues to work
  prepend           A PHP file to include before Composer's autoloader
  log-name          The fallback logger name [default: qless]
  help              Show this help message
  debug             Use verbose logging

HLP;

    fprintf(STDOUT, $help);

    exit(0);
}

// Find and initialize Composer
$autoload = [
    __DIR__ . '/vendor/autoload.php',
    __DIR__ . '/../../../vendor/autoload.php'
];

foreach ($autoload as $file) {
    if (class_exists(ClassLoader::class, false) == true) {
        break;
    }

    if (file_exists($file)) {
        require_once $file;
    }
}

if (class_exists(ClassLoader::class, false) == false) {
    fprintf(
        STDERR,
        'You need to set up the project dependencies using the following commands:' . PHP_EOL .
        'curl -s http://getcomposer.org/installer | php' . PHP_EOL .
        'php composer.phar install' . PHP_EOL
    );

    exit(1);
}

// Read the command line arguments
$params = (new Parser())->parse($argv);

if (isset($params['help']) || empty($params)) {
    help();
}

$prepend = $params['prepend'] ?? (getenv('APP_PREPEND') ?: null);
if (empty($prepend) == false) {
    foreach (explode(',', $prepend) as $file) {
        if (file_exists($file) == false) {
            fprintf(STDERR, 'A prepend file "%s" does not exist.' . PHP_EOL, $file);
            exit(1);
        }

        require_once $file;
    }
}

// See if the APP_PREPEND contains a logger object.
// If none exists, fallback to internal logger.
$logName = $params['log-name'] ?? (getenv('LOG_NAME') ?: 'qless');
if (!isset($logger) || $logger instanceof Logger == false) {
    $logger = new Logger($logName, [], [new PsrLogMessageProcessor()]);
}

$debug = false;
if (isset($params['debug'])) {
    $debug = true;
} else {
    $debug = getenv('DEBUG') || getenv('VERBOSE') || getenv('VVERBOSE') || false;
}

if (count($logger->getHandlers()) == 0) {
    $handler = new StreamHandler(STDOUT, $debug ? Logger::WARNING : Logger::DEBUG);

    $handler->setFormatter(
        new LineFormatter(
            "[%datetime%] %level_name%: %message%\n",
            null,
            false,
            true
        )
    );

    $logger->pushHandler($handler);
}

$logger->info('Start initializing qlessd...');
$database = $params['db'] ?? (getenv('REDIS_BACKEND_DB') ?: null);
$dsn = $params['dsn'] ?? (getenv('REDIS_BACKEND') ?: '127.0.0.1');

try {
    // Create a client
    $client = new Client($dsn, empty($database) ? null : (int)$database);

    // Get the queues you use.
    $queues = $params['queue'] ?? (getenv('QUEUE') ?: null);

    // Create a job reserver; different reservers use different
    // strategies for which order jobs are popped off of queues
    $reserver = new OrderedReserver(
        new Collection($client),
        empty($queue) ? null : explode(',', $queues),
        $params['queue-spec'] ?? null
    );

    $worker = new ForkingWorker($reserver, $client);
    $worker->setLogger($logger);

    $worker->run();
} catch (RedisConnectionException $e) {
    fprintf(
        STDERR,
        "%s Used connection DSN: %s\n",
        $e->getMessage(),
        $dsn
    );

    exit($e->getCode() ?: 1);
} catch (\Throwable $e) {
    fprintf(STDERR, "%s\n", $e->getMessage());

    exit($e->getCode() ?: 1);
}
